#!/usr/bin/env ruby
# frozen_string_literal: true

# Compile localized Markdown pages from YAML locale catalogs.
#
# Input per locale (pulled from Phrase):
#   i18n/locales/<locale>/index.yml
#   i18n/locales/<locale>/usage.yml
#   i18n/locales/<locale>/adapters.yml
#   i18n/locales/<locale>/configuration.yml
#   Each file has a single root key equal to the locale code (e.g., 'ja').
#
# English fallback catalogs (generated by extractor):
#   i18n/src/en/<page>.yml with root 'en'
#
# Source Markdown (structure reference):
#   docs/<page>.md — we traverse the original AST to preserve block order
#
# Output:
#   docs/_i18n/<locale>/<page>.md — localized Markdown with original structure
#
# Usage:
#   ruby scripts/md_compile_yml_locale.rb [--locales ja,es,pt-BR] [page ...]
#   - If no --locales provided, compiles for all directories under i18n/locales/*
#   - If no pages provided, defaults to [index, usage, adapters, configuration]
#
# Notes:
# - Requires kramdown + kramdown-parser-gfm (docs/Gemfile)
# - This script does not modify source Markdown

require 'yaml'
require 'fileutils'
require 'optparse'

begin
  require 'kramdown'
  require 'kramdown-parser-gfm'
rescue LoadError
  warn "Missing kramdown dependencies. Please run: (cd docs && bundle install)\n  And execute with: BUNDLE_GEMFILE=docs/Gemfile bundle exec ruby scripts/md_compile_yml_locale.rb"
  raise
end

ROOT = File.expand_path('..', __dir__)
DOCS_DIR = File.join(ROOT, 'docs')
I18N_EN_DIR = File.join(ROOT, 'i18n', 'src', 'en')
I18N_LOCALES_DIR = File.join(ROOT, 'i18n', 'locales')
OUT_BASE = File.join(ROOT, 'docs', '_i18n')
DEFAULT_PAGES = %w[index usage adapters configuration]

# Simple counter registry for deterministic keys
class Counters
  def initialize
    @c = Hash.new(0)
  end
  def next(key)
    @c[key] += 1
  end
  def current(key)
    @c[key]
  end
end

# Render inline children back to Markdown for fallback cases
module InlineRenderer
  module_function
  def render_children(el)
    (el.children || []).map { |c| render(c) }.join
  end
  def render(el)
    case el.type
    when :text
      el.value.to_s
    when :codespan
      "`#{el.value}`"
    when :em
      "*#{render_children(el)}*"
    when :strong
      "**#{render_children(el)}**"
    when :kbd
      "<kbd>#{render_children(el)}</kbd>"
    when :br
      "  \n"
    when :a
      label = (el.children || []).map { |c| render(c) }.join
      href  = el.attr && el.attr['href']
      title = el.attr && el.attr['title']
      title_part = title && !title.empty? ? " \"#{title}\"" : ''
      href ? "[#{label}](#{href}#{title_part})" : label
    when :img
      alt = el.attr && el.attr['alt']
      src = el.attr && el.attr['src']
      title = el.attr && el.attr['title']
      title_part = title && !title.empty? ? " \"#{title}\"" : ''
      src ? "![#{alt}](#{src}#{title_part})" : (alt || '')
    when :html_element, :html_raw
      el.value.to_s
    else
      render_children(el)
    end
  end
end

class Compiler
  def initialize(page, locale_code)
    @page = page
    @locale = locale_code
    @counters = Counters.new

    @en_map = load_en_map(page)
    @loc_map = load_locale_map(page, locale_code)

    @indent_stack = []
  end

  def compile
    md_path = File.join(DOCS_DIR, "#{@page}.md")
    content = File.read(md_path, encoding: 'UTF-8')
    fm, body = split_front_matter(content)

    doc = Kramdown::Document.new(body, input: 'GFM')
    out = String.new
    doc.root.children.each do |el|
      out << compile_node(el)
    end
    out = normalize_spacing(out)

    # Reattach front matter unchanged
    if fm
      "#{fm}#{out}"
    else
      out
    end
  end

  private

  def split_front_matter(content)
    if content.start_with?("---\n")
      parts = content.split(/^---\s*$\n/, -1)
      if parts.length >= 3
        fm = "---\n" + parts[1] + "---\n\n"
        body = parts[2..].join("---\n")
        return [fm, body]
      end
    end
    [nil, content]
  end

  def load_en_map(page)
    ypath = File.join(I18N_EN_DIR, "#{page}.yml")
    data = File.exist?(ypath) ? YAML.load_file(ypath) : {}
    data.is_a?(Hash) ? (data['en'] || {}) : {}
  end

  def load_locale_map(page, locale)
    ypath = File.join(I18N_LOCALES_DIR, locale, "#{page}.yml")
    data = File.exist?(ypath) ? YAML.load_file(ypath) : {}
    # Locale files use the locale code as root; if absent, try 'en' for fallback shape
    if data.is_a?(Hash)
      data[locale] || data['en'] || {}
    else
      {}
    end
  end

  def fetch(key)
    val = @loc_map[key]
    return val unless val.nil? || (val.respond_to?(:empty?) && val.empty?)
    @en_map[key]
  end

  def normalize_spacing(s)
    # Collapse 3+ consecutive newlines to 2
    s.gsub(/\n{3,}/, "\n\n").rstrip + "\n"
  end

  def compile_node(el, list_depth: 0)
    case el.type
    when :header
      lvl = el.options[:level]
      idx = @counters.next("h#{lvl}")
      key = format('%s_%03d', "h#{lvl}", idx)
      text = fetch(key) || InlineRenderer.render_children(el)
      "#{'#' * lvl} #{text}\n\n"
    when :p
      idx = @counters.next('p')
      key = format('%s_%03d', 'p', idx)
      text = fetch(key) || InlineRenderer.render_children(el)
      "#{text}\n\n"
    when :ul
      list_index = @counters.next('ul')
      key = format('%s_%03d', 'ul', list_index)
      list_map = fetch(key)
      compile_list(el, :ul, list_map, list_depth)
    when :ol
      list_index = @counters.next('ol')
      key = format('%s_%03d', 'ol', list_index)
      list_map = fetch(key)
      compile_list(el, :ol, list_map, list_depth)
    when :codeblock
      idx = @counters.next('code')
      key = format('%s_%03d', 'code', idx)
      code = fetch(key)
      code = el.value.to_s if code.nil? || code == ''
      lang = el.options && el.options[:lang]
      fence = "```#{lang}\n".dup
      fence << code.to_s
      fence << "\n````\n\n" if lang.to_s.end_with?('```') # edge-case safety
      fence << "\n```\n\n" unless fence.end_with?("\n````\n\n")
      # correct duplicate fence ending
      unless fence.end_with?("\n```\n\n")
        fence = fence.sub(/````\n\n\z/, "```\n\n")
      end
      fence
    when :blockquote
      inner = String.new
      (el.children || []).each { |c| inner << compile_node(c, list_depth: list_depth) }
      "> " + inner.split("\n").map { |ln| ln.empty? ? ">" : "> #{ln}" }.join("\n") + "\n\n"
    when :table
      compile_table(el)
    else
      out = String.new
      (el.children || []).each { |c| out << compile_node(c, list_depth: list_depth) }
      out
    end
  end

  def compile_list(list_el, kind, list_map, list_depth)
    out = String.new
    li_idx = 0
    (list_el.children || []).each do |li|
      next unless li.type == :li
      li_idx += 1
      item_key = format('li_%03d', li_idx)
      item_map = list_map.is_a?(Hash) ? list_map[item_key] : nil

      text = nil
      if item_map.is_a?(Hash)
        text = item_map['text']
      end
      if text.nil? || text.strip.empty?
        # fallback to original immediate text of li
        text = li_immediate_text(li)
      end

      indent = '  ' * list_depth
      marker = kind == :ul ? '-' : '1.'
      out << "#{indent}#{marker} #{text}\n"

      # nested lists under this li
      # We follow the item_map order if present, else original child order
      nested_blocks = []
      if item_map.is_a?(Hash)
        item_map.each do |k, v|
          next unless k.to_s.start_with?('ul_') || k.to_s.start_with?('ol_')
          nested_blocks << [k, v]
        end
      end

      if nested_blocks.empty?
        (li.children || []).each do |child|
          if child.type == :ul || child.type == :ol
            nested_blocks << [child.type == :ul ? 'ul' : 'ol', nil, child]
          end
        end
      end

      if !nested_blocks.empty?
        # Render using original child nodes where available so depth/order matches source
        (li.children || []).each do |child|
          next unless child.type == :ul || child.type == :ol
          n_kind = (child.type == :ul ? :ul : :ol)
          # Determine the appropriate nested key index based on encounter count
          # Count how many nested lists of this kind have been processed for this li so far
          # For simplicity, build key by counting existing nested of same kind in item_map
          nested_index = 1
          if item_map.is_a?(Hash)
            # find first missing nested key name
            loop do
              test_key = format('%s_%03d', n_kind, nested_index)
              break unless item_map.key?(test_key)
              break if item_map[test_key].is_a?(Hash)
              nested_index += 1
            end
          end
          nested_key = format('%s_%03d', n_kind, nested_index)
          nested_map = item_map.is_a?(Hash) ? item_map[nested_key] : nil
          out << compile_list(child, n_kind, nested_map, list_depth + 1)
        end
      end
    end
    out << "\n"
    out
  end

  def li_immediate_text(li_el)
    parts = []
    (li_el.children || []).each do |child|
      case child.type
      when :p, :header
        parts << InlineRenderer.render_children(child)
      when :codeblock
        parts << child.value.to_s
      when :ul, :ol
        # skip nested list content here
      else
        parts << InlineRenderer.render(child)
      end
    end
    parts.map { |s| s.to_s.strip }.reject(&:empty?).join("\n\n")
  end

  def compile_table(table_el)
    table_index = @counters.next('table')

    # Header row(s)
    headers = []
    thead = table_el.children.find { |c| c.type == :thead }
    if thead
      thead.children.each_with_index do |tr, r_idx|
        row = []
        tr.children.each_with_index do |th, c_idx|
          next unless th.type == :th
          key = format('table_%03d_th_r%02d_c%02d', table_index, r_idx + 1, c_idx + 1)
          val = fetch(key) || InlineRenderer.render_children(th)
          row << val
        end
        headers << row
      end
    end

    # Body rows
    body_rows = []
    tbodies = table_el.children.select { |c| c.type == :tbody }
    row_num = 0
    tbodies.each do |tbody|
      tbody.children.each do |tr|
        next unless tr.type == :tr
        row_num += 1
        row = []
        tr.children.each_with_index do |td, c_idx|
          next unless td.type == :td
          key = format('table_%03d_td_r%02d_c%02d', table_index, row_num, c_idx + 1)
          val = fetch(key) || InlineRenderer.render_children(td)
          row << val
        end
        body_rows << row
      end
    end

    # Build markdown table (use first header row or synthesize separator based on first body row width)
    out = String.new
    if headers.any?
      headers.each_with_index do |row, idx|
        out << "| #{row.join(' | ')} |\n"
        if idx == 0
          out << "| #{row.map { '---' }.join(' | ')} |\n"
        end
      end
    end
    body_rows.each do |row|
      out << "| #{row.join(' | ')} |\n"
    end
    out << "\n\n"
    out
  end
end

options = {}
OptionParser.new do |opts|
  opts.banner = 'Usage: md_compile_yml_locale.rb [--locales ja,es,pt-BR] [page ...]'
  opts.on('--locales LIST', 'Comma-separated list of locale codes to compile') do |list|
    options[:locales] = list.split(',').map(&:strip)
  end
end.parse!

pages = ARGV.empty? ? DEFAULT_PAGES : ARGV.map { |p| p.sub(/\.md\z/, '') }

locales = if options[:locales]&.any?
            options[:locales]
          else
            Dir.exist?(I18N_LOCALES_DIR) ? Dir.children(I18N_LOCALES_DIR).select { |d| File.directory?(File.join(I18N_LOCALES_DIR, d)) } : []
          end

if locales.empty?
  warn '[md-compile] No locales found under i18n/locales; nothing to compile.'
  exit 0
end

FileUtils.mkdir_p(OUT_BASE)

locales.each do |loc|
  out_dir = File.join(OUT_BASE, loc)
  FileUtils.mkdir_p(out_dir)
  pages.each do |page|
    md_src = File.join(DOCS_DIR, "#{page}.md")
    unless File.exist?(md_src)
      warn "[md-compile] Missing source: #{md_src}, skipping"
      next
    end
    compiled = Compiler.new(page, loc).compile
    out_path = File.join(out_dir, "#{page}.md")
    File.write(out_path, compiled, mode: 'w', encoding: 'UTF-8')
    puts "[md-compile] Wrote #{out_path}"
  end
end
